有说明语句int  a[4][5]  则a[2]+3表示: A

A.a数组行下标为2、列下标为3的元素的地址
B.a数组行下标为2、列下标为3的元素的值
C.a数组第2行的首地址
D.a数组第3行的首地址


关于数组初始化，下列说法不正确的是：D

A.二维数组初始化的时候，列数是必须给出的，行数可以由编译器来数。
B.二维数组初始化的时候，每行一个{}，逗号分隔。
C.对一维数组初始化的时候，即使给全部元素都赋了初值，也不能省略数组长度
D.二维数组初始化的时候，最后的逗号可以存在


1.对于定义 char str[] = “abc\000def\n”（注：其中0为数字零），求字符串str的长度len和数组str的大小size，len和size分别是：C
A. 12 ，13
B.3 ，11
C.3 ，9
D.3 ，4
题目分析：
\0是字符串结束符，字符串str的长度就是结束符之前的字符个数，也就是说长度len为3。对于size的话，/0算一个字符，/n不算做一个字符。

根据声明int a[10], *p=a; ，下列表达式错误的是（ C ）。
A.a[9]
B.p[5]
C.a++
D.*p++

对于已正确定义的二维数组a, *(a[i]+j)与a[i][j]的含义相同。

调用函数时，只能把实参的值传送给形参，形参的值不能传送给实参。

简单变量做形参时，实参和对应形参之间的数据传递方式为单向值传递。

函数可以嵌套调用，不可以嵌套定义。

在函数的说明和定义时若没有指出函数的类型，则系统自动地认为函数的类型为整型。

函数的实参可以是变量、常量或表达式。形参只能是变量。

变量生命周期是指变量从定义开始分配存储单元到运行结束存储单元被回收的整个过程。

局部变量和全局变量可以同名，但是它们代表不同的变量。 当同名的变量在同一个作用域中存在时，局部变量将会隐藏全局变量。 在代码块或函数内部，使用该变量名时，优先使用的是局部变量。

main 函数中定义的变量也是局部变量，只能在 main 函数中使用；同时，main 函数中也不能使用其它函数中定义的变量。

静态变量在整个程序运行期间都存在，但是仅在说明它的函数内是可见的,即只有说明塔的函数中可以调用。

使用static修饰符定义的局部变量，即使在声明时未赋初值，编译器也会把它初始化为0。

全局变量作用范围是整个程序。

函数执行完以后，其内部定义的静态变量不会被回收。

在一个C源程序文件中，若要定义一个只允许本源文件中所有函数使用的全局变量，则该变量需要使用的存储类别是 static 。

scanf，gets，getchar函数区别参考网址https://zhuanlan.zhihu.com/p/440145616

strlen函数计算字符串数组的长度，会忽略尾部的回车，但字符串长度不能忽略。

实参和与其对应的形参共占用一个存储单元。

在一个可以正确执行的C语言程序中，一个C语言函数的声明（原型）可以出现任意多次。

一个C语言源文件（.c文件）必须包含main函数。(错误)

变量的地址叫指针，存储指针的变量叫指针变量。

实参数组名是指针常量，形参数组名是指针变量。

function(a,b+c,(d,e))中有三个实参，分别是a，b+c，(d,e)。

定义int *p, a[3][4];则赋值p=a是错误的，只有int (*p)[4]可以，须保持类型一致。

*p="hello"，*p储存的是字符常量，不能再进行赋值操作，例如再进行*p=“world”是错误的，但是如果存储在字符数组里是可以再次赋值的，因为字符数组是一个变量，但自定义函数开头的算是变量如void function(char *p),这个p是变量。

类型相同的两个指针变量之间可以进行<（小于）、=（等于）、-（减法）运算。
1、“<（小于）”运算在两个同类型的指针间可以比较大小，比较原则应该是按照实际内存的高低位比较的
2、“=（等于）”是对于类型相同的两个指针变量之间常规运算。
3、“-（减法）”运算两个相同指针变量相减可以获得在之间相隔的同类型元素个数（在某个类型的数组中的应用）。
4、“+”运算是不可以的，因为两个指针相加什么都得不到，所以规定不允许相加。

结构是变量的集合，可以按照对同类型变量的操作方法单独使用其成员变量。

在定义结构类型时，关键字struct和它后面的结构名共同组成一个新的数据类型名。

用typedef只是将已存在的类型用一个新的标识符来代表。